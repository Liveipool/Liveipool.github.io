---
layout: post
title: ES6 标准入门(17)--异步操作和async函数   
date: 2017-02-07
categories: blog
description: JavaScript学习
---

# 异步操作和async函数      
异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。      

ES6 诞生以前，异步编程的方法，大概有下面四种。      
1. 回调函数      
2. 事件监听      
3. 发布/订阅      
4. Promise 对象      

ES6中的Generator 函数将 JavaScript 异步编程带入了一个全新的阶段，ES2017中的async函数更是给出了异步编程的终极解决方案。      

#### 异步      
所谓"异步"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。      
比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。      

#### 回调函数      
JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是"重新调用"。      

#### Promise      
回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为"回调函数地狱"（callback hell）。      
Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。      

### 协程及其Generator函数实现      
传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。      

协程有点像函数，又有点像线程。它的运行流程大致如下：      
1. 协程A开始执行。      
2. 协程A执行一部分，进入暂停，执行权转移到协程B。      
3. （一段时间后）协程B交还执行权。      
4. 协程A恢复执行。      

上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。      

举例来说，读取文件的协程写法如下。      

```
function* asyncJob() {
  // ...其他代码
  var f = yield readFile(fileA);
  // ...其他代码
}
```
上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。      
协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。      

**Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。**      
**整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。**      

### Thunk 函数      
**Thunk 函数是自动执行 Generator 函数的一种方法。**      

#### 参数的求值策略      
Thunk 函数早在上个世纪60年代就诞生了。      
那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是"求值策略"，即函数的参数到底应该何时求值。      

```
var x = 1;
function f(m){
  return m * 2;
}
f(x + 5)
```
上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？      

一种意见是**"传值调用"（call by value）**，即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f。C语言就采用这种策略。      

```
f(x + 5)
// 传值调用时，等同于
f(6)
```
另一种意见是**“传名调用”（call by name）**，即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。      

```
f(x + 5)
// 传名调用时，等同于
(x + 5) * 2
```
传值调用和传名调用，哪一种比较好？      
回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。      

```
function f(a, b){
  return b;
}
f(3 * x * x - 2 * x - 1, x);
```
上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于"传名调用"，即只在执行时求值。      

#### Thunk 函数的含义      
编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。      

```
function f(m) {
  return m * 2;
}
f(x + 5);
// 等同于
var thunk = function () {
  return x + 5;
};
function f(thunk) {
  return thunk() * 2;
}
```
上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。      
这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。      

#### JavaScript 语言的 Thunk 函数      
JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。      

```
// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);

// Thunk版本的readFile（单参数版本）
var Thunk = function (fileName) {
  return function (callback) {
    return fs.readFile(fileName, callback);
  };
};

var readFileThunk = Thunk(fileName);
readFileThunk(callback);
```
上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。      
任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。
还有一个Thunkify模块，是用于生产环境中的转换器。

**总的来说，Thunk函数是自动运行Generator函数的一种方法，还有书上介绍的一个”co模块“也可以让Generator函数自动执行。**      
**而async函数则是Generator函数的语法糖，但现在没什么特别深入的例子来学习Generator函数，因此这几种方法还不怎么看得懂，以后在实战中运用过Generator函数之后再倒回来详细学这一部分。**      